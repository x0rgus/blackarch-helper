#!/usr/bin/env bash
#
# blackarch-builder
# Helper to find, inspect, and build BlackArch tools from source.
# Author: Lucas "x0rgus" (Refactored by Gemini AI)
# License: MIT
# Repository: https://github.com/x0rgus/blackarch-helper

# --- Configuration ---
VERBOSE=false
CACHE_DIR="${HOME}/.cache/blackarch-builder"
DB_PATH="${CACHE_DIR}/blackarch.db.tar.gz"
BUILD_DIR="${CACHE_DIR}/builds"
REPO_URL="https://github.com/BlackArch/blackarch.git"

## --- Color and Symbol Configuration ---
COLOR_RESET=$'\033[0m'
COLOR_GREEN=$'\033[0;32m'
COLOR_YELLOW=$'\033[0;33m'
COLOR_RED=$'\033[0;31m'
COLOR_CYAN=$'\033[0;36m'
COLOR_BOLD=$'\033[1m'

# --- Logging Functions ---
einfo() { echo -e "${COLOR_GREEN}[INFO]${COLOR_RESET} $1"; }
ewarn() { echo -e "${COLOR_YELLOW}[WARN]${COLOR_RESET} $1"; } >&2
eerror() { echo -e "${COLOR_RED}[ERROR]${COLOR_RESET} $1"; } >&2
edie() { eerror "$1"; exit 1; }

# --- Core Functions ---
check_dependencies() {
    local missing_deps=()
    for dep in git makepkg curl fzf; do
        if ! command -v "$dep" &>/dev/null; then
            missing_deps+=("$dep")
        fi
    done

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        eerror "Required dependencies not found: ${missing_deps[*]}"
        ewarn "Please install them. On Arch Linux, try: sudo pacman -S --needed git base-devel curl fzf"
        exit 1
    fi
}

require_db() {
    if [[ ! -f "$DB_PATH" ]]; then
        edie "Local package database not found. Please run '$0 sync' first."
    fi
}

# --- Logic Functions (Backend) ---
_list_all_categories_from_db() {
    local CACHE_FILE="${CACHE_DIR}/categories.txt"
    if [[ -f "$CACHE_FILE" && "$CACHE_FILE" -nt "$DB_PATH" ]]; then
        cat "$CACHE_FILE"
        return
    fi

    einfo "Generating category list (this happens only once)..." >&2
    tar -xOf "$DB_PATH" --wildcards '*/desc' 2>/dev/null \
        | awk '/^%GROUPS%$/{p=1;next} /^%.*%$/{p=0} p' \
        | sort -u \
        | grep -v '^blackarch$' > "$CACHE_FILE"
    cat "$CACHE_FILE"
}

_list_tools_in_category() {
    local category="$1"
    einfo "Finding tools in category '${category}'..." >&2

    local all_packages
    all_packages=$(tar -tzf "$DB_PATH" | grep '/$')

    echo "$all_packages" | while read -r pkg_dir; do
        local groups_content
        groups_content=$(tar -xOf "$DB_PATH" "${pkg_dir}desc" 2>/dev/null | awk '/^%GROUPS%$/{p=1;next} /^%.*%$/{p=0} p')
        
        if echo "$groups_content" | grep -q -w "$category"; then
            echo "$pkg_dir" | sed 's|/||'
        fi
    done
}
_fetch_mirror_list() {
    local mirrorlist_url="https://raw.githubusercontent.com/BlackArch/blackarch-site/master/blackarch-mirrorlist"
    einfo "Fetching and processing mirror list from GitHub..." >&2
    
    local arch
    arch=$(uname -m)

    curl -sSfL "$mirrorlist_url" | \
        grep '^Server =' | \
        awk '{print $3}' | \
        sed "s|\$repo|blackarch|g; s|\$arch|${arch}|g"
}

_list_all_tools_from_db() {
    tar -tzf "$DB_PATH" | grep '/' | cut -d'/' -f1 | sort -u
}

_get_pkg_info() {
    local pkg_name="$1"
    local pkg_dir
    # FIX: Use '/' as the separator, not '-', to match the tarball's directory structure.
    pkg_dir=$(tar -tzf "$DB_PATH" | grep "^${pkg_name}/" | head -n 1)

    if [[ -z "$pkg_dir" ]]; then
        eerror "Package '$pkg_name' not found in local database."
        return 1
    fi

    local desc_content
    desc_content=$(tar -xOf "$DB_PATH" "${pkg_dir}desc")

    local awk_parser_script='BEGIN{p=0} $0==key{p=1;next} /^%[A-Z0-9_]+%$/{p=0} p'

    _parse_field() {
        awk -v key="$1" "$awk_parser_script" <<< "$desc_content"
    }

    printf "${COLOR_BOLD}Package Info: ${COLOR_CYAN}%s${COLOR_RESET}\n" "$(_parse_field '%NAME%')"
    printf "Version      : %s\n" "$(_parse_field '%VERSION%')"
    printf "Description  : %s\n" "$(_parse_field '%DESC%')"
    printf "Upstream URL : ${COLOR_CYAN}%s${COLOR_RESET}\n" "$(_parse_field '%URL%')"
    printf "Licenses     : %s\n" "$(_parse_field '%LICENSE%')"
    printf "Categories   : %s\n" "$(_parse_field '%GROUPS%' | paste -sd ' ' -)"
    printf "Depends On   : %s\n" "$(_parse_field '%DEPENDS%' | paste -sd ' ' - || echo 'None')"
}


# --- Subcommand Functions (User Interface) ---
handle_sync() {
    mkdir -p "$CACHE_DIR"
    local mirrors
    mirrors=$(_fetch_mirror_list)

    if [[ -z "$mirrors" ]]; then
        edie "Could not fetch a valid mirror list. Check your connection."
    fi

    local db_url=""
    local success=false
    for mirror in $mirrors; do
        db_url="${mirror}/blackarch.db.tar.gz"
        ewarn "Attempting to download from: ${db_url}"
        if curl --connect-timeout 10 -fL -o "$DB_PATH" "$db_url"; then
            einfo "Successfully downloaded database from ${mirror}"
            success=true
            break
        else
            ewarn "Failed to download from ${mirror}. Trying next..."
        fi
    done

    if [[ "$success" == "false" ]]; then
        edie "Failed to download database from all available mirrors."
    fi
}

handle_search() {
    require_db
    [[ -z "$1" ]] && edie "Usage: $0 search <keyword>"
    
    einfo "Searching for tools with the keyword '$1':"
    _list_all_tools_from_db | grep -i --color=auto "$1"
}

handle_info() {
    require_db
    [[ -z "$1" ]] && edie "Usage: $0 info <package-name>"
    
    _get_pkg_info "$1"
}

handle_install() {
    require_db
    local versioned_name="$1"
    [[ -z "$versioned_name" ]] && edie "Usage: $0 install <full-package-name-from-list>"

    einfo "Resolving source package for '${versioned_name}'..."
    local pkg_dir
    pkg_dir=$(tar -tzf "$DB_PATH" | grep "^${versioned_name}/" | head -n 1)
    if [[ -z "$pkg_dir" ]]; then
        edie "Could not find directory for '$versioned_name' in the database."
    fi
    local desc_content=$(tar -xOf "$DB_PATH" "${pkg_dir}desc")
    # FIX: Use %BASE% to get the source package name, which matches the git directory.
    local source_pkg_name=$(awk '/^%BASE%$/{getline; print; exit}' <<< "$desc_content")

    if [[ -z "$source_pkg_name" ]]; then
        edie "Could not determine source package name from %BASE% field for '$versioned_name'."
    fi
    einfo "Resolved to source package: '$source_pkg_name'"

    local pkg_build_dir="${BUILD_DIR}/${source_pkg_name}"
    
    # FIX: Build the prompt string correctly to allow variable expansion.
    local prompt_msg
    prompt_msg="${COLOR_YELLOW}[WARN]${COLOR_RESET} This will clone the PKGBUILD for '${COLOR_CYAN}${source_pkg_name}${COLOR_RESET}'. Proceed? (y/N) "
    einfo "Preparing to build '${versioned_name}' from source package '${source_pkg_name}'."
    read -p "$prompt_msg" -n 1 -r reply
    echo
    if [[ ! "$reply" =~ ^[Yy]$ ]]; then
        ewarn "Build cancelled by user."
        exit 0
    fi

    [[ -d "$pkg_build_dir" ]] && rm -rf "$pkg_build_dir"
    mkdir -p "$pkg_build_dir"

    einfo "Cloning PKGBUILD for '$source_pkg_name'..."
    if ! (cd "$pkg_build_dir" && \
          git init -q && \
          git remote add origin "$REPO_URL" && \
          git config core.sparseCheckout true && \
          echo "packages/${source_pkg_name}/" > .git/info/sparse-checkout && \
          git pull --depth=1 origin master); then
        edie "Failed to clone PKGBUILD for '$source_pkg_name'."
    fi

    local pkg_path_in_repo="${pkg_build_dir}/packages/${source_pkg_name}"
    if [[ ! -d "$pkg_path_in_repo" || ! -f "${pkg_path_in_repo}/PKGBUILD" ]]; then
        edie "Could not find a PKGBUILD for '$source_pkg_name' after cloning."
    fi

    einfo "Entering build directory: ${pkg_path_in_repo}"
    cd "$pkg_path_in_repo"

    einfo "Running 'makepkg -si'. This may ask for your sudo password."
    if ! makepkg -si --noconfirm; then
        edie "Build failed for '$source_pkg_name'."
    fi

    einfo "Successfully built and installed packages from source '$source_pkg_name'."
}

# Adapted interactive_menu with two-level navigation
interactive_menu() {
    require_db

    # Export functions and variables needed by the fzf preview subshell.
    export -f _get_pkg_info einfo ewarn eerror
    export DB_PATH COLOR_RESET COLOR_GREEN COLOR_YELLOW COLOR_RED COLOR_CYAN COLOR_BOLD

    while true; do
        local category
        category=$(_list_all_categories_from_db | fzf --prompt="▶ Category: " --height=40% --border \
            --header="Press ESC to exit")
        
        # Exit if user presses ESC in category menu
        [[ -z "$category" ]] && break

        while true; do
            einfo "Category: ${COLOR_CYAN}$category${COLOR_RESET}"
            
            local selected_tool
            selected_tool=$(_list_tools_in_category "$category" | fzf --prompt="▶ Tool: " --border \
                --header="ENTER to build | ESC to go back" \
                --preview-window 'right:60%:border-left' \
                --preview 'bash -c "_get_pkg_info {}"')

            # Go back to categories if user presses ESC in tool menu
            [[ -z "$selected_tool" ]] && break

            handle_install "$selected_tool"
            
            einfo "Press any key to continue browsing this category..."
            read -n 1 -s
        done
    done

    einfo "Exiting."
}

usage() {
    cat <<EOF

${COLOR_BOLD}blackarch-builder${COLOR_RESET}: Find, inspect, and build BlackArch packages from source.

${COLOR_BOLD}USAGE:${COLOR_RESET}
    blackarch-builder <command> [argument]

${COLOR_BOLD}COMMANDS:${COLOR_RESET}
    ${COLOR_CYAN}sync${COLOR_RESET}            Downloads the BlackArch package database from an official mirror.
    ${COLOR_CYAN}search${COLOR_RESET} <keyword> Searches for a package by name in the local database.
    ${COLOR_CYAN}info${COLOR_RESET} <pkg>      Shows information about a specific package.
    ${COLOR_CYAN}install${COLOR_RESET} <pkg>   Clones the PKGBUILD and builds the package using 'makepkg'.
    ${COLOR_CYAN}interactive${COLOR_RESET}      Opens an interactive menu to search and build packages.
    ${COLOR_CYAN}help${COLOR_RESET}             Shows this help message.

${COLOR_BOLD}WORKFLOW EXAMPLE:${COLOR_RESET}
    1. ${COLOR_YELLOW}blackarch-builder sync${COLOR_RESET}
    2. ${COLOR_YELLOW}blackarch-builder search metasploit${COLOR_RESET}
    3. ${COLOR_YELLOW}blackarch-builder info metasploit${COLOR_RESET}
    4. ${COLOR_YELLOW}blackarch-builder install metasploit${COLOR_RESET}

EOF
}

# --- Main Execution ---
check_dependencies
mkdir -p "$CACHE_DIR"

if [[ $# -eq 0 ]]; then
    usage
    exit 0
fi

case "$1" in
    sync)
        handle_sync
        ;;
    search)
        handle_search "$2"
        ;;
    info)
        handle_info "$2"
        ;;
    install)
        handle_install "$2"
        ;;
    interactive | fzf)
        interactive_menu
        ;;
    help | --help | -h)
        usage
        ;;
    *)
        eerror "Unknown command '$1'."
        usage
        exit 1
        ;;
esac
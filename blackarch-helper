#!/usr/bin/env bash
#
# blackarch-helper
# Helper to find, inspect, and build BlackArch tools from source.
# Author: Lucas "x0rgus"
# License: MIT
# Repository: https://github.com/x0rgus/blackarch-helper

# --- Configuration ---
CACHE_DIR="${HOME}/.cache/blackarch-helper"
DB_PATH="${CACHE_DIR}/blackarch.db.tar.gz"
BUILD_DIR="${CACHE_DIR}/builds"
REPO_URL="https://github.com/BlackArch/blackarch.git"
FALLBACK_MIRROR="https://www.blackarch.org/blackarch"

# --- Robustness and Cleanup ---
set -Eeuo pipefail
trap 'eerror "An error occurred. Exiting."; exit 1' ERR
trap 'echo -e "\n${COLOR_YELLOW}Execution interrupted by user.${COLOR_RESET}"; exit 1' INT

## --- Color and Symbol Configuration ---
COLOR_RESET=$'\033[0m'
COLOR_GREEN=$'\033[0;32m'
COLOR_YELLOW=$'\033[0;33m'
COLOR_RED=$'\033[0;31m'
COLOR_CYAN=$'\033[0;36m'
COLOR_BOLD=$'\033[1m'

# --- Logging Functions ---
einfo() { echo -e "${COLOR_GREEN}[INFO]${COLOR_RESET} $1"; }
ewarn() { echo -e "${COLOR_YELLOW}[WARN]${COLOR_RESET} $1"; } >&2
eerror() { echo -e "${COLOR_RED}[ERROR]${COLOR_RESET} $1"; } >&2
edie() { eerror "$1"; exit 1; }

# --- Core Functions ---
check_dependencies() {
    local missing_deps=()
    for dep in git makepkg curl fzf; do
        if ! command -v "$dep" &>/dev/null; then
            missing_deps+=("$dep")
        fi
    done

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        eerror "Required dependencies not found: ${missing_deps[*]}"
        ewarn "Please install them. On Arch Linux, try: sudo pacman -S --needed git base-devel curl fzf"
        exit 1
    fi
}

require_db() {
    if [[ ! -f "$DB_PATH" ]]; then
        edie "Local package database not found. Please run '$0 sync' first."
    fi
}

# --- Logic Functions (Backend) ---
_update_tool_index() {
    local INDEX_FILE="${CACHE_DIR}/tool_index.txt"
    if [[ -f "$INDEX_FILE" && "$INDEX_FILE" -nt "$DB_PATH" ]]; then
        return
    fi

    einfo "Generating tool index for fast category searching..." >&2
    ewarn "This is a one-time operation and may take up to a minute." >&2

    local process_script='
        versioned_name=$(dirname "$TAR_FILENAME")
        desc_content=$(cat)
        base_name=$(echo "$desc_content" | awk "/^%BASE%$/{getline; print; exit}")
        groups=$(echo "$desc_content" | awk "/^%GROUPS%$/{p=1;next} /^%.*%$/{p=0} p")

        if [[ -n "$base_name" ]]; then
            for group in $groups; do
                echo "${group}:${base_name}:${versioned_name}"
            done
        fi
    '
    tar -xf "$DB_PATH" --wildcards '*/desc' --to-command="bash -c '$process_script'" 2>/dev/null > "$INDEX_FILE"
}

_list_all_categories() {
    local INDEX_FILE="${CACHE_DIR}/tool_index.txt"
    cut -d: -f1 "$INDEX_FILE" | sort -u | grep -v '^blackarch$'
}

_list_tools_in_category() {
    local category="$1"
    local INDEX_FILE="${CACHE_DIR}/tool_index.txt"
    
    local installed_pkgs
    installed_pkgs=$(pacman -Qq)

    grep "^${category}:" "$INDEX_FILE" | while IFS=: read -r _ base_name versioned_name; do
        if echo "$installed_pkgs" | grep -q -w "^${base_name}$"; then
            printf "âœ” %s\n" "$versioned_name"
        else
            printf "  %s\n" "$versioned_name"
        fi
    done
}

_get_pkg_info() {
    local pkg_name
    pkg_name=$(echo "$1" | cut -c3-)

    local pkg_dir
    pkg_dir=$(tar -tzf "$DB_PATH" | grep "^${pkg_name}/" | head -n 1)

    if [[ -z "$pkg_dir" ]]; then
        eerror "Package '$pkg_name' not found in local database."
        return 1
    fi

    local desc_content
    desc_content=$(tar -xOf "$DB_PATH" "${pkg_dir}desc")

    local awk_parser_script='BEGIN{p=0} $0==key{p=1;next} /^%[A-Z0-9_]+%$/{p=0} p'

    _parse_field() {
        awk -v key="$1" "$awk_parser_script" <<< "$desc_content"
    }

    printf "${COLOR_BOLD}Package Info${COLOR_RESET}\n"
    printf "Name         : %s\n" "$(_parse_field '%NAME%')"
    printf "Source Pkg   : %s\n" "$(_parse_field '%BASE%')"
    printf "Version      : %s\n" "$(_parse_field '%VERSION%')"
    printf "Description  : %s\n" "$(_parse_field '%DESC%')"
    printf "Upstream URL : ${COLOR_CYAN}%s${COLOR_RESET}\n" "$(_parse_field '%URL%')"
    printf "Licenses     : %s\n" "$(_parse_field '%LICENSE%')"
    printf "Categories   : %s\n" "$(_parse_field '%GROUPS%' | paste -sd ' ' -)"
    printf "Depends On   : %s\n" "$(_parse_field '%DEPENDS%' | paste -sd ' ' - || echo 'None')"
}

_prepare_build_env() {
    local pkg_identifier="$1"
    local versioned_name=""
    local source_pkg_name=""
    local INDEX_FILE="${CACHE_DIR}/tool_index.txt"

    if grep -q ":${pkg_identifier}$" "$INDEX_FILE"; then
        versioned_name="$pkg_identifier"
    else
        local matches
        matches=$(grep ":${pkg_identifier}:" "$INDEX_FILE")
        local count
        count=$(echo "$matches" | wc -l)

        if [[ $count -eq 0 ]]; then
            edie "Package matching '$pkg_identifier' not found in the index."
        elif [[ $count -gt 1 ]]; then
            eerror "Multiple packages found for base name '$pkg_identifier'. Please specify the full versioned name:"
            echo "$matches" | cut -d: -f3 | sed 's/^/  - /' >&2
            exit 1
        else
            versioned_name=$(echo "$matches" | cut -d: -f3)
            einfo "Found unique package for '${pkg_identifier}': ${versioned_name}"
        fi
    fi

    einfo "Resolving source package for '${versioned_name}'..." >&2
    local pkg_dir
    pkg_dir=$(tar -tzf "$DB_PATH" | grep "^${versioned_name}/" | head -n 1)
    if [[ -z "$pkg_dir" ]]; then
        edie "Could not find directory for '$versioned_name' in the database."
    fi
    local desc_content
    desc_content=$(tar -xOf "$DB_PATH" "${pkg_dir}desc")
    source_pkg_name=$(awk '/^%BASE%$/{getline; print; exit}' <<< "$desc_content")

    if [[ -z "$source_pkg_name" ]]; then
        edie "Could not determine source package name for '$versioned_name'."
    fi
    einfo "Resolved to source package: '$source_pkg_name'" >&2

    local pkg_build_dir="${BUILD_DIR}/${source_pkg_name}"
    
    [[ -d "$pkg_build_dir" ]] && rm -rf "$pkg_build_dir"
    mkdir -p "$pkg_build_dir"

    einfo "Cloning PKGBUILD for '$source_pkg_name'..." >&2
    if ! (cd "$pkg_build_dir" && \
          git init -q && \
          git remote add origin "$REPO_URL" && \
          git config core.sparseCheckout true && \
          echo "packages/${source_pkg_name}/" > .git/info/sparse-checkout && \
          git pull --depth=1 origin master >/dev/null 2>&1); then
        edie "Failed to clone PKGBUILD for '$source_pkg_name'."
    fi
    
    echo "$source_pkg_name"
}

# --- Mirror Management Functions ---
_fetch_raw_mirror_list() {
    local mirrorlist_url="https://raw.githubusercontent.com/BlackArch/blackarch-site/master/blackarch-mirrorlist"
    einfo "Fetching raw mirror list from GitHub..." >&2
    
    # FIX: Get ALL servers, commented or not, and clean them up.
    curl -sSfL "$mirrorlist_url" | grep 'Server =' | sed -e 's/^#//' -e 's/Server = //'
}

_rank_mirrors() {
    local -a raw_mirrors
    # FIX: Use readarray to safely load mirrors into an array.
    readarray -t raw_mirrors < <(printf '%s\n' "$@")
    local arch
    arch=$(uname -m)
    
    einfo "Ranking mirrors by latency in parallel... (testing up to ${#raw_mirrors[@]} mirrors)" >&2
    
    local temp_file
    temp_file=$(mktemp)
    # Ensure temp file is cleaned up on exit
    trap 'rm -f "$temp_file"' RETURN

    local batch_size=10
    local completed=0
    for i in "${!raw_mirrors[@]}"; do
        # This block runs in the background for each mirror
        {
            local mirror="${raw_mirrors[$i]}"
            local formatted_mirror
            formatted_mirror=$(echo "$mirror" | sed "s|\$repo|blackarch|g; s|\$arch|${arch}|g")
            
            local latency
            latency=$(LC_NUMERIC=C curl -o /dev/null -s -w '%{time_total}' --connect-timeout 3 --max-time 5 "${formatted_mirror}/blackarch.db.tar.gz.sig" || echo "999")
            
            if [[ "$latency" != "999" ]]; then
                # Write results to a temporary file to handle parallel writes safely
                LC_NUMERIC=C printf "%.3f %s\n" "$latency" "$formatted_mirror" >> "$temp_file"
            fi
        } &

        # Wait for a batch of processes to finish before starting the next one
        if (( (i + 1) % batch_size == 0 )) || (( (i + 1) == ${#raw_mirrors[@]} )); then
            wait
            completed=$((i + 1))
            ewarn "(${completed}/${#raw_mirrors[@]}) mirrors tested..."
        fi
    done
    wait

    # Sort the collected results and return only the URLs
    sort -n "$temp_file" | awk '{print $2}'
}


# --- Subcommand Functions (User Interface) ---
handle_sync() {
    local custom_mirror="${1:-}"
    mkdir -p "$CACHE_DIR"
    
    local mirrors_to_try=()
    if [[ -n "$custom_mirror" ]]; then
        einfo "Using custom mirror provided: $custom_mirror"
        mirrors_to_try=("$custom_mirror")
    else
        local raw_mirrors
        raw_mirrors=$(_fetch_raw_mirror_list)
        if [[ -z "$raw_mirrors" ]]; then
            edie "Could not fetch a valid mirror list from GitHub."
        fi
        
        local ranked_mirrors
        ranked_mirrors=$(_rank_mirrors "${raw_mirrors[@]}")
        readarray -t mirrors_to_try <<< "$ranked_mirrors"
    fi

    if [[ ${#mirrors_to_try[@]} -eq 0 ]]; then
        ewarn "No functional mirrors found after ranking. Attempting to use the official fallback mirror."
        local arch
        arch=$(uname -m)
        mirrors_to_try=("$(echo "$FALLBACK_MIRROR" | sed "s|\$repo|blackarch|g; s|\$arch|${arch}|g")")
    fi

    einfo "Will attempt to download from the best available mirrors..."
    local success=false
    for mirror in "${mirrors_to_try[@]}"; do
        local db_url="${mirror}/blackarch.db.tar.gz"
        ewarn "Attempting to download from: ${db_url}"
        if curl --progress-bar -fL -o "$DB_PATH" "$db_url"; then
            einfo "Successfully downloaded database from ${mirror}"
            success=true
            break
        else
            ewarn "Failed to download from ${mirror}. Trying next..."
        fi
    done

    if [[ "$success" == "false" ]]; then
        edie "Failed to download database from all available mirrors."
    fi

    einfo "Sync complete. Forcing tool index regeneration."
    rm -f "${CACHE_DIR}/tool_index.txt"
    _update_tool_index
}

handle_rank_mirrors() {
    local raw_mirrors
    raw_mirrors=$(_fetch_raw_mirror_list)
    local ranked_mirrors
    ranked_mirrors=$(_rank_mirrors "${raw_mirrors[@]}")

    if [[ -z "$ranked_mirrors" ]]; then
        edie "Could not find any functional mirrors to rank."
    fi

    einfo "Top mirrors sorted by speed:"
    local count=1
    while read -r mirror; do
        printf " ${COLOR_CYAN}%2d.${COLOR_RESET} %s\n" "$count" "$mirror"
        ((count++))
    done <<< "$ranked_mirrors"

    read -p "${COLOR_YELLOW}[WARN]${COLOR_RESET} How many of the fastest mirrors do you want to save to your system mirrorlist? (e.g., 5, or 0 to cancel) " num_mirrors
    if [[ ! "$num_mirrors" =~ ^[0-9]+$ ]] || [[ "$num_mirrors" -eq 0 ]]; then
        ewarn "Operation cancelled."
        exit 0
    fi
    
    local mirrorlist_path="/etc/pacman.d/blackarch-mirrorlist"
    ewarn "This will overwrite your '${mirrorlist_path}' with the top ${num_mirrors} mirrors."
    ewarn "A backup of your current file will be created at '${mirrorlist_path}.bak'."
    read -p "${COLOR_RED}[DANGER]${COLOR_RESET} Are you sure you want to proceed? (y/N) " -n 1 -r reply
    echo
    if [[ ! "$reply" =~ ^[Yy]$ ]]; then
        ewarn "Operation cancelled."
        exit 0
    fi
    
    einfo "Backing up current mirrorlist..."
    sudo cp "$mirrorlist_path" "${mirrorlist_path}.bak"
    
    einfo "Generating new mirrorlist content..."
    local new_content="# BlackArch Mirrorlist generated by blackarch-helper on $(date -R)\n"
    local arch
    arch=$(uname -m)
    new_content+=$(echo "$ranked_mirrors" | head -n "$num_mirrors" | sed "s|/blackarch/os/${arch}|/\$repo/os/\$arch|" | sed 's/^/Server = /')

    einfo "Writing new mirrorlist to '${mirrorlist_path}' with sudo..."
    echo -e "$new_content" | sudo tee "$mirrorlist_path" > /dev/null
    
    einfo "Successfully updated BlackArch mirrorlist."
    ewarn "You may want to run 'sudo pacman -Syy' to refresh package databases with the new mirrors."
}

handle_search() {
    require_db
    _update_tool_index
    [[ -z "$1" ]] && edie "Usage: $0 search <keyword>"
    
    printf "${COLOR_GREEN}[INFO]${COLOR_RESET} Searching for tools with the keyword '%s':\n" "$1"
    printf "${COLOR_BOLD}%-30s %s${COLOR_RESET}\n" "Base Name" "Full Name for (install, review, info)"
    
    cut -d: -f2,3 "${CACHE_DIR}/tool_index.txt" | sort -u | grep -i --color=auto "$1" | sed -e 's/:/ /'
}

handle_info() {
    require_db
    [[ -z "$1" ]] && edie "Usage: $0 info <package-name>"
    
    _get_pkg_info "  $1"
}

handle_install() {
    require_db
    local pkg_identifier="$1"
    [[ -z "$pkg_identifier" ]] && edie "Usage: $0 install <package-name>"

    local source_pkg_name
    source_pkg_name=$(_prepare_build_env "$pkg_identifier")

    local prompt_msg
    prompt_msg="${COLOR_YELLOW}[WARN]${COLOR_RESET} This will build and install '${COLOR_CYAN}${pkg_identifier}${COLOR_RESET}'. Proceed? (y/N) "
    read -p "$prompt_msg" -n 1 -r reply
    echo
    if [[ ! "$reply" =~ ^[Yy]$ ]]; then
        ewarn "Build cancelled by user."
        exit 0
    fi

    local pkg_path_in_repo="${BUILD_DIR}/${source_pkg_name}/packages/${source_pkg_name}"
    if [[ ! -d "$pkg_path_in_repo" || ! -f "${pkg_path_in_repo}/PKGBUILD" ]]; then
        edie "Could not find a PKGBUILD for '$source_pkg_name' after cloning."
    fi

    einfo "Entering build directory: ${pkg_path_in_repo}"
    cd "$pkg_path_in_repo"

    einfo "Running 'makepkg -si'..."
    if ! makepkg -si --noconfirm; then
        edie "Build failed for '$source_pkg_name'."
    fi

    einfo "Successfully built and installed packages from source '$source_pkg_name'."
}

handle_review() {
    require_db
    local pkg_identifier="$1"
    [[ -z "$pkg_identifier" ]] && edie "Usage: $0 review <package-name>"

    local source_pkg_name
    source_pkg_name=$(_prepare_build_env "$pkg_identifier")
    
    local pkg_path_in_repo="${BUILD_DIR}/${source_pkg_name}/packages/${source_pkg_name}"
    if [[ ! -f "${pkg_path_in_repo}/PKGBUILD" ]]; then
        edie "Could not find a PKGBUILD for '$source_pkg_name' after cloning."
    fi

    einfo "Displaying PKGBUILD for '$source_pkg_name':"
    echo -e "${COLOR_CYAN}--- START PKGBUILD ---${COLOR_RESET}"
    cat "${pkg_path_in_repo}/PKGBUILD"
    echo -e "${COLOR_CYAN}--- END PKGBUILD ---${COLOR_RESET}"

    local prompt_msg
    prompt_msg="${COLOR_YELLOW}[WARN]${COLOR_RESET} Proceed with building and installing this package? (y/N) "
    read -p "$prompt_msg" -n 1 -r reply
    echo
    if [[ ! "$reply" =~ ^[Yy]$ ]]; then
        ewarn "Build cancelled by user."
        exit 0
    fi
    
    einfo "Entering build directory: ${pkg_path_in_repo}"
    cd "$pkg_path_in_repo"

    einfo "Running 'makepkg -si'..."
    if ! makepkg -si --noconfirm; then
        edie "Build failed for '$source_pkg_name'."
    fi

    einfo "Successfully built and installed packages from source '$source_pkg_name'."
}

handle_clean_cache() {
    ewarn "This will permanently delete the cache directory at ${CACHE_DIR}."
    read -p "${COLOR_YELLOW}[WARN]${COLOR_RESET} Are you sure you want to continue? (y/N) " -n 1 -r reply
    echo
    if [[ "$reply" =~ ^[Yy]$ ]]; then
        einfo "Removing cache directory..."
        rm -rf "$CACHE_DIR"
        einfo "Cache cleared."
    else
        ewarn "Operation cancelled."
    fi
}

interactive_menu() {
    require_db
    _update_tool_index

    export -f _get_pkg_info einfo ewarn eerror
    export DB_PATH COLOR_RESET COLOR_GREEN COLOR_YELLOW COLOR_RED COLOR_CYAN COLOR_BOLD

    while true; do
        local category
        category=$(_list_all_categories | fzf --prompt="â–¶ Category: " --height=40% --border \
            --header="Press ESC to exit")
        
        [[ -z "$category" ]] && break

        while true; do
            einfo "Category: ${COLOR_CYAN}$category${COLOR_RESET}"
            
            local selected_tool
            selected_tool=$(_list_tools_in_category "$category" | fzf --prompt="â–¶ Tool: " --border \
                --header="âœ” = Installed | ENTER to build | ESC to go back" \
                --preview-window 'right:60%:border-left' \
                --preview 'bash -c "_get_pkg_info {}"')

            [[ -z "$selected_tool" ]] && break

            local clean_tool_name
            clean_tool_name=$(echo "$selected_tool" | cut -c3-)
            handle_install "$clean_tool_name"
            
            einfo "Press any key to continue browsing this category..."
            read -n 1 -s
        done
    done

    einfo "Exiting."
}

usage() {
    cat <<EOF

${COLOR_BOLD}blackarch-helper${COLOR_RESET}: Find, inspect, and build BlackArch packages from source.

${COLOR_BOLD}USAGE:${COLOR_RESET}
    blackarch-helper [OPTIONS] <command> [argument]

${COLOR_BOLD}OPTIONS:${COLOR_RESET}
    ${COLOR_YELLOW}--mirror <url>${COLOR_RESET}   Use a specific mirror for the 'sync' command, skipping ranking.

${COLOR_BOLD}COMMANDS:${COLOR_RESET}
    ${COLOR_CYAN}sync${COLOR_RESET}              Downloads the package database from the fastest mirror.
    ${COLOR_CYAN}rank-mirrors${COLOR_RESET}      Tests and ranks mirrors, with an option to update the system mirrorlist.
    ${COLOR_CYAN}interactive${COLOR_RESET}        Opens the interactive TUI menu to browse and build.
    ${COLOR_CYAN}review <package>${COLOR_RESET}      Review the PKGBUILD for a package before building.
    ${COLOR_CYAN}install <package>${COLOR_RESET}     Build and install a package directly.
    ${COLOR_CYAN}info <package>${COLOR_RESET}         Shows information about a specific package.
    ${COLOR_CYAN}search <keyword>${COLOR_RESET}      Searches for a package by a keyword.
    ${COLOR_CYAN}clean-cache${COLOR_RESET}      Deletes the local cache directory.
    ${COLOR_CYAN}help${COLOR_RESET}               Shows this help message.

${COLOR_BOLD}WORKFLOW EXAMPLE:${COLOR_RESET}
    1. ${COLOR_YELLOW}blackarch-helper sync${COLOR_RESET}
    2. ${COLOR_YELLOW}blackarch-helper interactive${COLOR_RESET}
    3. ${COLOR_YELLOW}blackarch-helper rank-mirrors${COLOR_RESET}

EOF
}

# --- Main Execution ---
main() {
    local custom_mirror=""
    local args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --mirror)
                if [[ -n "$2" ]]; then
                    custom_mirror="$2"
                    shift 2
                else
                    edie "--mirror option requires an argument."
                fi
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    set -- "${args[@]}"

    check_dependencies
    mkdir -p "$CACHE_DIR"

    if [[ $# -eq 0 ]]; then
        interactive_menu
        exit 0
    fi

    case "$1" in
        sync)
            handle_sync "$custom_mirror"
            ;;
        rank-mirrors)
            handle_rank_mirrors
            ;;
        search)
            handle_search "$2"
            ;;
        info)
            handle_info "$2"
            ;;
        install)
            handle_install "$2"
            ;;
        review)
            handle_review "$2"
            ;;
        clean-cache)
            handle_clean_cache
            ;;
        interactive | fzf)
            interactive_menu
            ;;
        help | --help | -h)
            usage
            ;;
        *)
            eerror "Unknown command '$1'."
            usage
            exit 1
            ;;
    esac
}

main "$@"